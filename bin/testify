#!/usr/bin/env node

"use strict";

// From: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
if (!Object.assign) {
	Object.defineProperty(Object,"assign",{
		enumerable: false,
		configurable: true,
		writable: true,
		value: function(target, firstSource) {
			"use strict";
			if (target === undefined || target === null) {
				throw new TypeError('Cannot convert first argument to object');
			}

			var to = Object(target);
			for (var i = 1; i < arguments.length; i++) {
				var nextSource = arguments[i];
				if (nextSource === undefined || nextSource === null) {
					continue;
				}
				nextSource = Object(nextSource);

				var keysArray = Object.keys(Object(nextSource));
				for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
					var nextKey = keysArray[nextIndex];
					var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
					if (desc !== undefined && desc.enumerable) {
						to[nextKey] = nextSource[nextKey];
					}
				}
			}
			return to;
		}
	});
}

var fs = require("fs"),
	path = require("path"),
	args = require("minimist")(process.argv,{ string: ["file","dir"] }),
	ft = require(path.join(__dirname,"..","lib","featuretests.js")),
	acorn = require("acorn"),
	walk = require("acorn/dist/walk"),

	parse_options = {
		ecmaVersion: 6,
		allowHashBang: true
	},
	walk_visitors = {},
	walk_handlers = Object.assign({},walk.base),

	tests_needed = Object.assign({},ft.es6),

	homedir = process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'],
	files = [],
	output = ""
;

// setup AST walk visitors
Object.keys(walk.base).forEach(function eacher(type){
	walk_visitors[type] = visitNode;
});

// setup AST walk handler overrides
walk_handlers.Function = function(node,st,c) {
	if (!Array.isArray(st)) st = [];
	st.push("FNDECL");
	if (node.params.length > 0) {
		st.push("FNARGS");

		for (var i = 0; i < node.params.length; i++) {
			c(node.params[i], st, "Pattern");
		}

		st.pop();
	}
	c(node.body, st, "ScopeBody");
	st.pop();
};

// initialize `tests_needed`
Object.keys(tests_needed).forEach(function eacher(test){
	tests_needed[test] = false;
});

// verify CLI usage
if (args.help ||
	!(
		args.file ||
		args.dir
	)
) {
	printHelp();
	process.exit(1);
}

// include manually specified files
if (args.file) {
	if (!Array.isArray(args.file)) args.file = [args.file];
	files = files.concat(args.file.map(fixPath));
}

// include files from any specified directories
if (args.dir) {
	if (!Array.isArray(args.dir)) args.dir = [args.dir];
	args.dir.forEach(function eacher(dir){
		try {
			dir = fixPath(dir);
			files = files.concat(
					fs.readdirSync(dir)
					.map(function mapper(file){
						return path.join(dir,file);
					})
				);
		}
		catch (err) {
			console.error("Couldn't find directory:", dir);
			process.exit(1);
		}
	});
}

// filter out any non-existent or non-file paths
files = files.filter(function filterer(filepath){
	try {
		if (fs.existsSync(filepath)) {
			var stat = fs.statSync(filepath);
			if (stat.isFile()) return true;
		}
	}
	catch (err) { }
	return false;
});

// scan all files to populate `tests_needed`
files.forEach(scanFile);

// filter out any tests not needed
tests_needed = Object.keys(tests_needed)
	.filter(function filterer(test){
		return tests_needed[test];
	});

// populate output
if (tests_needed.length > 0) {
	output += "function checkFeatureTests(testResults){return ";
	tests_needed.forEach(function eacher(test,idx){
		output += (idx > 0 ? "&&" : "");
		if (test == "class") output += "testResults[\"" + test + "\"]";
		else output += "testResults." + test;
	});
	output += "}";
}
else {
	output = "function checkFeatureTests(testResults){return true}";
}

console.log(output);

// ***********************************

function printHelp() {
	console.log(
		"testify: scanning for ES features to test\n",
		"(c) 2015 Kyle Simpson | http://getify.mit-license.org/\n",
		"\n",
		"usage: testify opt [, ..opt]\n",
		"\n",
		"options:\n",
		"--help                    show this help\n",
		"\n",
		"--file=file               scan a single file\n",
		"--dir=directory           scan all files in a directory",
		"\n"
	);
}

// from: https://github.com/azer/expand-home-dir
function expandHomeDir(fpath) {
	if (!fpath) return fpath;
	if (fpath == '~') return homedir;
	if (fpath.slice(0, 2) != '~/') return fpath;
	return path.join(homedir,fpath.slice(2));
}

function fixPath(pathStr) {
	if (!path.isAbsolute(pathStr)) {
		if (/^~/.test(pathStr)) {
			pathStr = pathStr.replace(/^~/,function replacer(){
				return expandHomeDir("~");
			});
		}
		else if (!(new RegExp("^[" + path.sep + "]")).test(pathStr)) {
			pathStr = path.join(__dirname,"..",pathStr);
		}
	}
	return pathStr;
}

function scanFile(filepath) {
	var contents = fs.readFileSync(filepath,{ encoding: "utf8" }),
		ast = acorn.parse(contents,parse_options);

	walk.simple(ast,walk_visitors,walk_handlers);
}

function visitNode(node,state) {
	if (!tests_needed.letConst &&
		node.type == "VariableDeclaration" &&
		(
			node.kind == "let" ||
			node.kind == "const"
		)
	) {
		tests_needed.letConst = true;
	}
	else if (!tests_needed.templateString &&
		(
			node.type == "TemplateLiteral" ||
			node.type == "TaggedTemplateExpression"
		)
	) {
		tests_needed.templateString = true;
	}
	else if (!tests_needed.forOf &&
		node.type == "ForOfStatement"
	) {
		tests_needed.forOf = true;
	}
	else if (!tests_needed.arrow &&
		node.type == "ArrowFunctionExpression"
	) {
		tests_needed.arrow = true;
	}
	else if (!tests_needed.generator &&
		(
			node.type == "FunctionDeclaration" ||
			node.type == "FunctionExpression" ||
			node.type == "MethodExpression"
		) &&
		node.generator
	) {
		tests_needed.generator = true;
	}
	else if (!tests_needed["class"] &&
		(
			node.type == "ClassDeclaration" ||
			node.type == "ClassExpression"
		)
	) {
		tests_needed["class"] = true;
	}
	else if (!tests_needed.spreadRest &&
		(
			node.type == "SpreadElement" ||
			node.type == "RestElement"
		)
	) {
		tests_needed.spreadRest = true;
	}
	else if (!tests_needed.symbol &&
		node.type == "Identifier" &&
		node.name == "Symbol"
	) {
		tests_needed.symbol = true;
	}
	else if (!tests_needed.moduleExport &&
		(
			node.type == "ExportNamedDeclaration" ||
			node.type == "ExportDefaultDeclaration" ||
			node.type == "ExportAllDeclaration"
		)
	) {
		tests_needed.moduleExport = true;
	}
	else if (!tests_needed.moduleImport &&
		node.type == "ImportDeclaration"
	) {
		tests_needed.moduleImport = true;
	}
	else if (!tests_needed.computedProperty &&
		node.type == "Property" &&
		node.computed
	) {
		tests_needed.computedProperty = true;
	}
	else if (!tests_needed.conciseMethodProperty &&
		node.type == "Property" &&
		(
			node.shorthand ||
			node.method
		)
	) {
		tests_needed.conciseMethodProperty = true;
	}
	else if (!tests_needed.defaultParameter &&
		node.type == "AssignmentPattern" &&
		Array.isArray(state) &&
		state[state.length-1] == "FNARGS"
	) {
		tests_needed.defaultParameter = true;
	}

	// TODO: add in the rest of the ES6 syntax checks
}
